// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.190730.2

#ifndef WINRT_Windows_UI_Xaml_Input_H
#define WINRT_Windows_UI_Xaml_Input_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.190730.2"), "Mismatched C++/WinRT headers.");
#include "winrt/Windows.UI.Xaml.h"
#include "winrt/impl/Windows.Devices.Input.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.System.2.h"
#include "winrt/impl/Windows.UI.Core.2.h"
#include "winrt/impl/Windows.UI.Input.2.h"
#include "winrt/impl/Windows.UI.Xaml.2.h"
#include "winrt/impl/Windows.UI.Xaml.Input.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyDisplayRequestedEventArgs<D>::PressedKeys() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs)->get_PressedKeys(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyInvokedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyInvokedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::IsDisplayModeEnabled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics)->get_IsDisplayModeEnabled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::IsDisplayModeEnabledChanged(Windows::Foundation::TypedEventHandler<Windows::Foundation::IInspectable, Windows::Foundation::IInspectable> const& value) const
    {
        winrt::event_token token;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics)->add_IsDisplayModeEnabledChanged(*(void**)(&value), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::IsDisplayModeEnabledChanged_revoker consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::IsDisplayModeEnabledChanged(auto_revoke_t, Windows::Foundation::TypedEventHandler<Windows::Foundation::IInspectable, Windows::Foundation::IInspectable> const& value) const
    {
        return impl::make_event_revoker<D, IsDisplayModeEnabledChanged_revoker>(this, IsDisplayModeEnabledChanged(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::IsDisplayModeEnabledChanged(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics)->remove_IsDisplayModeEnabledChanged(impl::bind_in(token)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics<D>::ExitDisplayMode() const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics)->ExitDisplayMode());
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics2<D>::AreKeyTipsEnabled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics2)->get_AreKeyTipsEnabled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IAccessKeyManagerStatics2<D>::AreKeyTipsEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IAccessKeyManagerStatics2)->put_AreKeyTipsEnabled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICharacterReceivedRoutedEventArgs<D>::Character() const
    {
        char16_t value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs)->get_Character(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICharacterReceivedRoutedEventArgs<D>::KeyStatus() const
    {
        Windows::UI::Core::CorePhysicalKeyStatus value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs)->get_KeyStatus(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICharacterReceivedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICharacterReceivedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICommand<D>::CanExecuteChanged(Windows::Foundation::EventHandler<Windows::Foundation::IInspectable> const& value) const
    {
        winrt::event_token token;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICommand)->add_CanExecuteChanged(*(void**)(&value), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Windows_UI_Xaml_Input_ICommand<D>::CanExecuteChanged_revoker consume_Windows_UI_Xaml_Input_ICommand<D>::CanExecuteChanged(auto_revoke_t, Windows::Foundation::EventHandler<Windows::Foundation::IInspectable> const& value) const
    {
        return impl::make_event_revoker<D, CanExecuteChanged_revoker>(this, CanExecuteChanged(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICommand<D>::CanExecuteChanged(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICommand)->remove_CanExecuteChanged(impl::bind_in(token)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICommand<D>::CanExecute(Windows::Foundation::IInspectable const& parameter) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICommand)->CanExecute(*(void**)(&parameter), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ICommand<D>::Execute(Windows::Foundation::IInspectable const& parameter) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ICommand)->Execute(*(void**)(&parameter)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IContextRequestedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IContextRequestedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IContextRequestedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IContextRequestedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IContextRequestedEventArgs<D>::TryGetPosition(Windows::UI::Xaml::UIElement const& relativeTo, Windows::Foundation::Point& point) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IContextRequestedEventArgs)->TryGetPosition(*(void**)(&relativeTo), impl::bind_out(point), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IDoubleTappedRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IDoubleTappedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IDoubleTappedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IDoubleTappedRoutedEventArgs<D>::GetPosition(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        Windows::Foundation::Point returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs)->GetPosition(*(void**)(&relativeTo), put_abi(returnValue)));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::SearchRoot() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->get_SearchRoot(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::SearchRoot(Windows::UI::Xaml::DependencyObject const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->put_SearchRoot(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::ExclusionRect() const
    {
        Windows::Foundation::Rect value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->get_ExclusionRect(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::ExclusionRect(Windows::Foundation::Rect const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->put_ExclusionRect(impl::bind_in(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::HintRect() const
    {
        Windows::Foundation::Rect value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->get_HintRect(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::HintRect(Windows::Foundation::Rect const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->put_HintRect(impl::bind_in(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::XYFocusNavigationStrategyOverride() const
    {
        Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->get_XYFocusNavigationStrategyOverride(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFindNextElementOptions<D>::XYFocusNavigationStrategyOverride(Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFindNextElementOptions)->put_XYFocusNavigationStrategyOverride(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics<D>::GetFocusedElement() const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics)->GetFocusedElement(&returnValue));
        return Windows::Foundation::IInspectable{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics2<D>::TryMoveFocus(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics2)->TryMoveFocus(static_cast<int32_t>(focusNavigationDirection), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics3<D>::FindNextFocusableElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics3)->FindNextFocusableElement(static_cast<int32_t>(focusNavigationDirection), &result));
        return Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics3<D>::FindNextFocusableElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::Foundation::Rect const& hintRect) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics3)->FindNextFocusableElementWithHint(static_cast<int32_t>(focusNavigationDirection), impl::bind_in(hintRect), &result));
        return Windows::UI::Xaml::UIElement{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics4<D>::TryMoveFocus(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics4)->TryMoveFocusWithOptions(static_cast<int32_t>(focusNavigationDirection), *(void**)(&focusNavigationOptions), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics4<D>::FindNextElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics4)->FindNextElement(static_cast<int32_t>(focusNavigationDirection), &returnValue));
        return Windows::UI::Xaml::DependencyObject{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics4<D>::FindFirstFocusableElement(Windows::UI::Xaml::DependencyObject const& searchScope) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics4)->FindFirstFocusableElement(*(void**)(&searchScope), &returnValue));
        return Windows::UI::Xaml::DependencyObject{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics4<D>::FindLastFocusableElement(Windows::UI::Xaml::DependencyObject const& searchScope) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics4)->FindLastFocusableElement(*(void**)(&searchScope), &returnValue));
        return Windows::UI::Xaml::DependencyObject{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics4<D>::FindNextElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics4)->FindNextElementWithOptions(static_cast<int32_t>(focusNavigationDirection), *(void**)(&focusNavigationOptions), &returnValue));
        return Windows::UI::Xaml::DependencyObject{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics5<D>::TryFocusAsync(Windows::UI::Xaml::DependencyObject const& element, Windows::UI::Xaml::FocusState const& value) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics5)->TryFocusAsync(*(void**)(&element), static_cast<int32_t>(value), &returnValue));
        return Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics5<D>::TryMoveFocusAsync(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics5)->TryMoveFocusAsync(static_cast<int32_t>(focusNavigationDirection), &returnValue));
        return Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusManagerStatics5<D>::TryMoveFocusAsync(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusManagerStatics5)->TryMoveFocusWithOptionsAsync(static_cast<int32_t>(focusNavigationDirection), *(void**)(&focusNavigationOptions), &returnValue));
        return Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IFocusMovementResult<D>::Succeeded() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IFocusMovementResult)->get_Succeeded(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::OldFocusedElement() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_OldFocusedElement(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::NewFocusedElement() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_NewFocusedElement(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::NewFocusedElement(Windows::UI::Xaml::DependencyObject const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->put_NewFocusedElement(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::FocusState() const
    {
        Windows::UI::Xaml::FocusState value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_FocusState(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::Direction() const
    {
        Windows::UI::Xaml::Input::FocusNavigationDirection value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_Direction(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::InputDevice() const
    {
        Windows::UI::Xaml::Input::FocusInputDeviceKind value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_InputDevice(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::Cancel() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->get_Cancel(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs<D>::Cancel(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs)->put_Cancel(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs2<D>::TryCancel() const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs2)->TryCancel(&returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IGettingFocusEventArgs2<D>::TrySetNewFocusedElement(Windows::UI::Xaml::DependencyObject const& element) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IGettingFocusEventArgs2)->TrySetNewFocusedElement(*(void**)(&element), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IHoldingRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IHoldingRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IHoldingRoutedEventArgs<D>::HoldingState() const
    {
        Windows::UI::Input::HoldingState value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IHoldingRoutedEventArgs)->get_HoldingState(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IHoldingRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IHoldingRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IHoldingRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IHoldingRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IHoldingRoutedEventArgs<D>::GetPosition(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        Windows::Foundation::Point returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IHoldingRoutedEventArgs)->GetPosition(*(void**)(&relativeTo), put_abi(returnValue)));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaExpansionBehavior<D>::DesiredDeceleration() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaExpansionBehavior)->get_DesiredDeceleration(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaExpansionBehavior<D>::DesiredDeceleration(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaExpansionBehavior)->put_DesiredDeceleration(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaExpansionBehavior<D>::DesiredExpansion() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaExpansionBehavior)->get_DesiredExpansion(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaExpansionBehavior<D>::DesiredExpansion(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaExpansionBehavior)->put_DesiredExpansion(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaRotationBehavior<D>::DesiredDeceleration() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaRotationBehavior)->get_DesiredDeceleration(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaRotationBehavior<D>::DesiredDeceleration(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaRotationBehavior)->put_DesiredDeceleration(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaRotationBehavior<D>::DesiredRotation() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaRotationBehavior)->get_DesiredRotation(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaRotationBehavior<D>::DesiredRotation(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaRotationBehavior)->put_DesiredRotation(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaTranslationBehavior<D>::DesiredDeceleration() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaTranslationBehavior)->get_DesiredDeceleration(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaTranslationBehavior<D>::DesiredDeceleration(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaTranslationBehavior)->put_DesiredDeceleration(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaTranslationBehavior<D>::DesiredDisplacement() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaTranslationBehavior)->get_DesiredDisplacement(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInertiaTranslationBehavior<D>::DesiredDisplacement(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInertiaTranslationBehavior)->put_DesiredDisplacement(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInputScope<D>::Names() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInputScope)->get_Names(&value));
        return Windows::Foundation::Collections::IVector<Windows::UI::Xaml::Input::InputScopeName>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInputScopeName<D>::NameValue() const
    {
        Windows::UI::Xaml::Input::InputScopeNameValue value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInputScopeName)->get_NameValue(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInputScopeName<D>::NameValue(Windows::UI::Xaml::Input::InputScopeNameValue const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInputScopeName)->put_NameValue(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IInputScopeNameFactory<D>::CreateInstance(Windows::UI::Xaml::Input::InputScopeNameValue const& nameValue) const
    {
        void* instance{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IInputScopeNameFactory)->CreateInstance(static_cast<int32_t>(nameValue), &instance));
        return Windows::UI::Xaml::Input::InputScopeName{ instance, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs<D>::Key() const
    {
        Windows::System::VirtualKey value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs)->get_Key(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs<D>::KeyStatus() const
    {
        Windows::UI::Core::CorePhysicalKeyStatus value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs)->get_KeyStatus(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs2<D>::OriginalKey() const
    {
        Windows::System::VirtualKey value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs2)->get_OriginalKey(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyRoutedEventArgs3<D>::DeviceId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyRoutedEventArgs3)->get_DeviceId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Key() const
    {
        Windows::System::VirtualKey value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->get_Key(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Key(Windows::System::VirtualKey const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->put_Key(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Modifiers() const
    {
        Windows::System::VirtualKeyModifiers value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->get_Modifiers(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Modifiers(Windows::System::VirtualKeyModifiers const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->put_Modifiers(static_cast<uint32_t>(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::IsEnabled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->get_IsEnabled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::IsEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->put_IsEnabled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::ScopeOwner() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->get_ScopeOwner(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::ScopeOwner(Windows::UI::Xaml::DependencyObject const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->put_ScopeOwner(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Invoked(Windows::Foundation::TypedEventHandler<Windows::UI::Xaml::Input::KeyboardAccelerator, Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs> const& value) const
    {
        winrt::event_token token;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->add_Invoked(*(void**)(&value), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Invoked_revoker consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Invoked(auto_revoke_t, Windows::Foundation::TypedEventHandler<Windows::UI::Xaml::Input::KeyboardAccelerator, Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs> const& value) const
    {
        return impl::make_event_revoker<D, Invoked_revoker>(this, Invoked(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAccelerator<D>::Invoked(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAccelerator)->remove_Invoked(impl::bind_in(token)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorFactory<D>::CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const
    {
        void* instance{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory)->CreateInstance(*(void**)(&outer), impl::bind_out(inner), &instance));
        return Windows::UI::Xaml::Input::KeyboardAccelerator{ instance, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorInvokedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorInvokedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorInvokedEventArgs<D>::Element() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs)->get_Element(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorInvokedEventArgs2<D>::KeyboardAccelerator() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2)->get_KeyboardAccelerator(&value));
        return Windows::UI::Xaml::Input::KeyboardAccelerator{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorStatics<D>::KeyProperty() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics)->get_KeyProperty(&value));
        return Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorStatics<D>::ModifiersProperty() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics)->get_ModifiersProperty(&value));
        return Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorStatics<D>::IsEnabledProperty() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics)->get_IsEnabledProperty(&value));
        return Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IKeyboardAcceleratorStatics<D>::ScopeOwnerProperty() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics)->get_ScopeOwnerProperty(&value));
        return Windows::UI::Xaml::DependencyProperty{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::OldFocusedElement() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_OldFocusedElement(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::NewFocusedElement() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_NewFocusedElement(&value));
        return Windows::UI::Xaml::DependencyObject{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::NewFocusedElement(Windows::UI::Xaml::DependencyObject const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->put_NewFocusedElement(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::FocusState() const
    {
        Windows::UI::Xaml::FocusState value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_FocusState(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::Direction() const
    {
        Windows::UI::Xaml::Input::FocusNavigationDirection value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_Direction(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::InputDevice() const
    {
        Windows::UI::Xaml::Input::FocusInputDeviceKind value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_InputDevice(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::Cancel() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->get_Cancel(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs<D>::Cancel(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs)->put_Cancel(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs2<D>::TryCancel() const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs2)->TryCancel(&returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ILosingFocusEventArgs2<D>::TrySetNewFocusedElement(Windows::UI::Xaml::DependencyObject const& element) const
    {
        bool returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ILosingFocusEventArgs2)->TrySetNewFocusedElement(*(void**)(&element), &returnValue));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Container() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_Container(&value));
        return Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Position() const
    {
        Windows::Foundation::Point value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_Position(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::IsInertial() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_IsInertial(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Cumulative() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_Cumulative(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Velocities() const
    {
        Windows::UI::Input::ManipulationVelocities value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_Velocities(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationCompletedRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Container() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Container(&value));
        return Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Position() const
    {
        Windows::Foundation::Point value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Position(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::IsInertial() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_IsInertial(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Delta() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Delta(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Cumulative() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Cumulative(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Velocities() const
    {
        Windows::UI::Input::ManipulationVelocities value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Velocities(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationDeltaRoutedEventArgs<D>::Complete() const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs)->Complete());
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Container() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_Container(&value));
        return Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::ExpansionBehavior() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_ExpansionBehavior(&value));
        return Windows::UI::Xaml::Input::InertiaExpansionBehavior{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::ExpansionBehavior(Windows::UI::Xaml::Input::InertiaExpansionBehavior const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->put_ExpansionBehavior(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::RotationBehavior() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_RotationBehavior(&value));
        return Windows::UI::Xaml::Input::InertiaRotationBehavior{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::RotationBehavior(Windows::UI::Xaml::Input::InertiaRotationBehavior const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->put_RotationBehavior(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::TranslationBehavior() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_TranslationBehavior(&value));
        return Windows::UI::Xaml::Input::InertiaTranslationBehavior{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::TranslationBehavior(Windows::UI::Xaml::Input::InertiaTranslationBehavior const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->put_TranslationBehavior(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Delta() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_Delta(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Cumulative() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_Cumulative(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationInertiaStartingRoutedEventArgs<D>::Velocities() const
    {
        Windows::UI::Input::ManipulationVelocities value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs)->get_Velocities(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationPivot<D>::Center() const
    {
        Windows::Foundation::Point value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationPivot)->get_Center(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationPivot<D>::Center(Windows::Foundation::Point const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationPivot)->put_Center(impl::bind_in(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationPivot<D>::Radius() const
    {
        double value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationPivot)->get_Radius(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationPivot<D>::Radius(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationPivot)->put_Radius(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationPivotFactory<D>::CreateInstanceWithCenterAndRadius(Windows::Foundation::Point const& center, double radius) const
    {
        void* instance{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationPivotFactory)->CreateInstanceWithCenterAndRadius(impl::bind_in(center), radius, &instance));
        return Windows::UI::Xaml::Input::ManipulationPivot{ instance, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Container() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->get_Container(&value));
        return Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Position() const
    {
        Windows::Foundation::Point value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->get_Position(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Cumulative() const
    {
        Windows::UI::Input::ManipulationDelta value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->get_Cumulative(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgs<D>::Complete() const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs)->Complete());
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartedRoutedEventArgsFactory<D>::CreateInstance(Windows::Foundation::IInspectable const& outer, Windows::Foundation::IInspectable& inner) const
    {
        void* instance{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory)->CreateInstance(*(void**)(&outer), impl::bind_out(inner), &instance));
        return Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs{ instance, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Mode() const
    {
        Windows::UI::Xaml::Input::ManipulationModes value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->get_Mode(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Mode(Windows::UI::Xaml::Input::ManipulationModes const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->put_Mode(static_cast<uint32_t>(value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Container() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->get_Container(&value));
        return Windows::UI::Xaml::UIElement{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Container(Windows::UI::Xaml::UIElement const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->put_Container(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Pivot() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->get_Pivot(&value));
        return Windows::UI::Xaml::Input::ManipulationPivot{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Pivot(Windows::UI::Xaml::Input::ManipulationPivot const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->put_Pivot(*(void**)(&value)));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IManipulationStartingRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_INoFocusCandidateFoundEventArgs<D>::Direction() const
    {
        Windows::UI::Xaml::Input::FocusNavigationDirection value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs)->get_Direction(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_INoFocusCandidateFoundEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_INoFocusCandidateFoundEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_INoFocusCandidateFoundEventArgs<D>::InputDevice() const
    {
        Windows::UI::Xaml::Input::FocusInputDeviceKind value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs)->get_InputDevice(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointer<D>::PointerId() const
    {
        uint32_t value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointer)->get_PointerId(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointer<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointer)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointer<D>::IsInContact() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointer)->get_IsInContact(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointer<D>::IsInRange() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointer)->get_IsInRange(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::Pointer() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->get_Pointer(&value));
        return Windows::UI::Xaml::Input::Pointer{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::KeyModifiers() const
    {
        Windows::System::VirtualKeyModifiers value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->get_KeyModifiers(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::GetCurrentPoint(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->GetCurrentPoint(*(void**)(&relativeTo), &returnValue));
        return Windows::UI::Input::PointerPoint{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs<D>::GetIntermediatePoints(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        void* returnValue{};
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs)->GetIntermediatePoints(*(void**)(&relativeTo), &returnValue));
        return Windows::Foundation::Collections::IVector<Windows::UI::Input::PointerPoint>{ returnValue, take_ownership_from_abi };
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IPointerRoutedEventArgs2<D>::IsGenerated() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IPointerRoutedEventArgs2)->get_IsGenerated(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IProcessKeyboardAcceleratorEventArgs<D>::Key() const
    {
        Windows::System::VirtualKey value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs)->get_Key(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IProcessKeyboardAcceleratorEventArgs<D>::Modifiers() const
    {
        Windows::System::VirtualKeyModifiers value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs)->get_Modifiers(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IProcessKeyboardAcceleratorEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IProcessKeyboardAcceleratorEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IRightTappedRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IRightTappedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IRightTappedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_IRightTappedRoutedEventArgs<D>::GetPosition(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        Windows::Foundation::Point returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs)->GetPosition(*(void**)(&relativeTo), put_abi(returnValue)));
        return returnValue;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ITappedRoutedEventArgs<D>::PointerDeviceType() const
    {
        Windows::Devices::Input::PointerDeviceType value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ITappedRoutedEventArgs)->get_PointerDeviceType(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ITappedRoutedEventArgs<D>::Handled() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ITappedRoutedEventArgs)->get_Handled(&value));
        return value;
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ITappedRoutedEventArgs<D>::Handled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ITappedRoutedEventArgs)->put_Handled(value));
    }
    template <typename D> auto consume_Windows_UI_Xaml_Input_ITappedRoutedEventArgs<D>::GetPosition(Windows::UI::Xaml::UIElement const& relativeTo) const
    {
        Windows::Foundation::Point returnValue;
        check_hresult(WINRT_IMPL_SHIM(Windows::UI::Xaml::Input::ITappedRoutedEventArgs)->GetPosition(*(void**)(&relativeTo), put_abi(returnValue)));
        return returnValue;
    }
    template <typename H> struct delegate<Windows::UI::Xaml::Input::DoubleTappedEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::DoubleTappedEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::DoubleTappedEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::HoldingEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::HoldingEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::HoldingEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::HoldingRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::KeyEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::KeyEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::KeyEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::KeyRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::ManipulationCompletedEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::ManipulationCompletedEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::ManipulationCompletedEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::ManipulationDeltaEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::ManipulationDeltaEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::ManipulationDeltaEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::ManipulationStartedEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::ManipulationStartedEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::ManipulationStartedEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::ManipulationStartingEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::ManipulationStartingEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::ManipulationStartingEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::PointerEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::PointerEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::PointerEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::PointerRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::RightTappedEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::RightTappedEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::RightTappedEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::RightTappedRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Windows::UI::Xaml::Input::TappedEventHandler, H> final : implements_delegate<Windows::UI::Xaml::Input::TappedEventHandler, H>
    {
        delegate(H&& handler) : implements_delegate<Windows::UI::Xaml::Input::TappedEventHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* e) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Windows::UI::Xaml::Input::TappedRoutedEventArgs const*>(&e));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs>
    {
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs>
    {
        int32_t __stdcall get_PressedKeys(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().PressedKeys());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyManager> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyManager>
    {
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyManagerStatics> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>
    {
        int32_t __stdcall get_IsDisplayModeEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsDisplayModeEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_IsDisplayModeEnabledChanged(void* value, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().IsDisplayModeEnabledChanged(*reinterpret_cast<Windows::Foundation::TypedEventHandler<Windows::Foundation::IInspectable, Windows::Foundation::IInspectable> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_IsDisplayModeEnabledChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsDisplayModeEnabledChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall ExitDisplayMode() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExitDisplayMode();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IAccessKeyManagerStatics2> : produce_base<D, Windows::UI::Xaml::Input::IAccessKeyManagerStatics2>
    {
        int32_t __stdcall get_AreKeyTipsEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().AreKeyTipsEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AreKeyTipsEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AreKeyTipsEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs>
    {
        int32_t __stdcall get_Character(char16_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<char16_t>(this->shim().Character());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyStatus(struct struct_Windows_UI_Core_CorePhysicalKeyStatus* value) noexcept final try
        {
            zero_abi<Windows::UI::Core::CorePhysicalKeyStatus>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Core::CorePhysicalKeyStatus>(this->shim().KeyStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::ICommand> : produce_base<D, Windows::UI::Xaml::Input::ICommand>
    {
        int32_t __stdcall add_CanExecuteChanged(void* value, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().CanExecuteChanged(*reinterpret_cast<Windows::Foundation::EventHandler<Windows::Foundation::IInspectable> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_CanExecuteChanged(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CanExecuteChanged(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall CanExecute(void* parameter, bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().CanExecute(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&parameter)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Execute(void* parameter) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Execute(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&parameter));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IContextRequestedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IContextRequestedEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryGetPosition(void* relativeTo, Windows::Foundation::Point* point, bool* returnValue) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(point);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TryGetPosition(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo), *reinterpret_cast<Windows::Foundation::Point*>(point)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPosition(void* relativeTo, Windows::Foundation::Point* returnValue) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::Point>(this->shim().GetPosition(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFindNextElementOptions> : produce_base<D, Windows::UI::Xaml::Input::IFindNextElementOptions>
    {
        int32_t __stdcall get_SearchRoot(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().SearchRoot());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SearchRoot(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SearchRoot(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExclusionRect(Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Rect>(this->shim().ExclusionRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExclusionRect(Windows::Foundation::Rect value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExclusionRect(*reinterpret_cast<Windows::Foundation::Rect const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HintRect(Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Rect>(this->shim().HintRect());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HintRect(Windows::Foundation::Rect value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HintRect(*reinterpret_cast<Windows::Foundation::Rect const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_XYFocusNavigationStrategyOverride(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride>(this->shim().XYFocusNavigationStrategyOverride());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_XYFocusNavigationStrategyOverride(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().XYFocusNavigationStrategyOverride(*reinterpret_cast<Windows::UI::Xaml::Input::XYFocusNavigationStrategyOverride const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManager> : produce_base<D, Windows::UI::Xaml::Input::IFocusManager>
    {
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManagerStatics> : produce_base<D, Windows::UI::Xaml::Input::IFocusManagerStatics>
    {
        int32_t __stdcall GetFocusedElement(void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::IInspectable>(this->shim().GetFocusedElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManagerStatics2> : produce_base<D, Windows::UI::Xaml::Input::IFocusManagerStatics2>
    {
        int32_t __stdcall TryMoveFocus(int32_t focusNavigationDirection, bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TryMoveFocus(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManagerStatics3> : produce_base<D, Windows::UI::Xaml::Input::IFocusManagerStatics3>
    {
        int32_t __stdcall FindNextFocusableElement(int32_t focusNavigationDirection, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::UI::Xaml::UIElement>(this->shim().FindNextFocusableElement(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindNextFocusableElementWithHint(int32_t focusNavigationDirection, Windows::Foundation::Rect hintRect, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::UI::Xaml::UIElement>(this->shim().FindNextFocusableElement(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection), *reinterpret_cast<Windows::Foundation::Rect const*>(&hintRect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManagerStatics4> : produce_base<D, Windows::UI::Xaml::Input::IFocusManagerStatics4>
    {
        int32_t __stdcall TryMoveFocusWithOptions(int32_t focusNavigationDirection, void* focusNavigationOptions, bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TryMoveFocus(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection), *reinterpret_cast<Windows::UI::Xaml::Input::FindNextElementOptions const*>(&focusNavigationOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindNextElement(int32_t focusNavigationDirection, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().FindNextElement(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindFirstFocusableElement(void* searchScope, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().FindFirstFocusableElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&searchScope)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindLastFocusableElement(void* searchScope, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().FindLastFocusableElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&searchScope)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FindNextElementWithOptions(int32_t focusNavigationDirection, void* focusNavigationOptions, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().FindNextElement(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection), *reinterpret_cast<Windows::UI::Xaml::Input::FindNextElementOptions const*>(&focusNavigationOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusManagerStatics5> : produce_base<D, Windows::UI::Xaml::Input::IFocusManagerStatics5>
    {
        int32_t __stdcall TryFocusAsync(void* element, int32_t value, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>>(this->shim().TryFocusAsync(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&element), *reinterpret_cast<Windows::UI::Xaml::FocusState const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryMoveFocusAsync(int32_t focusNavigationDirection, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>>(this->shim().TryMoveFocusAsync(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryMoveFocusWithOptionsAsync(int32_t focusNavigationDirection, void* focusNavigationOptions, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::IAsyncOperation<Windows::UI::Xaml::Input::FocusMovementResult>>(this->shim().TryMoveFocusAsync(*reinterpret_cast<Windows::UI::Xaml::Input::FocusNavigationDirection const*>(&focusNavigationDirection), *reinterpret_cast<Windows::UI::Xaml::Input::FindNextElementOptions const*>(&focusNavigationOptions)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IFocusMovementResult> : produce_base<D, Windows::UI::Xaml::Input::IFocusMovementResult>
    {
        int32_t __stdcall get_Succeeded(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Succeeded());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IGettingFocusEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IGettingFocusEventArgs>
    {
        int32_t __stdcall get_OldFocusedElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().OldFocusedElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewFocusedElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().NewFocusedElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NewFocusedElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NewFocusedElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FocusState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::FocusState>(this->shim().FocusState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Direction(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusNavigationDirection>(this->shim().Direction());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InputDevice(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusInputDeviceKind>(this->shim().InputDevice());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IGettingFocusEventArgs2> : produce_base<D, Windows::UI::Xaml::Input::IGettingFocusEventArgs2>
    {
        int32_t __stdcall TryCancel(bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TryCancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TrySetNewFocusedElement(void* element, bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TrySetNewFocusedElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IHoldingRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IHoldingRoutedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HoldingState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::HoldingState>(this->shim().HoldingState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPosition(void* relativeTo, Windows::Foundation::Point* returnValue) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::Point>(this->shim().GetPosition(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInertiaExpansionBehavior> : produce_base<D, Windows::UI::Xaml::Input::IInertiaExpansionBehavior>
    {
        int32_t __stdcall get_DesiredDeceleration(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredDeceleration(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DesiredExpansion(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredExpansion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredExpansion(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredExpansion(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInertiaRotationBehavior> : produce_base<D, Windows::UI::Xaml::Input::IInertiaRotationBehavior>
    {
        int32_t __stdcall get_DesiredDeceleration(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredDeceleration(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DesiredRotation(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredRotation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredRotation(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredRotation(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInertiaTranslationBehavior> : produce_base<D, Windows::UI::Xaml::Input::IInertiaTranslationBehavior>
    {
        int32_t __stdcall get_DesiredDeceleration(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredDeceleration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredDeceleration(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredDeceleration(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DesiredDisplacement(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().DesiredDisplacement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DesiredDisplacement(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DesiredDisplacement(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInputScope> : produce_base<D, Windows::UI::Xaml::Input::IInputScope>
    {
        int32_t __stdcall get_Names(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::IVector<Windows::UI::Xaml::Input::InputScopeName>>(this->shim().Names());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInputScopeName> : produce_base<D, Windows::UI::Xaml::Input::IInputScopeName>
    {
        int32_t __stdcall get_NameValue(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::InputScopeNameValue>(this->shim().NameValue());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NameValue(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NameValue(*reinterpret_cast<Windows::UI::Xaml::Input::InputScopeNameValue const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IInputScopeNameFactory> : produce_base<D, Windows::UI::Xaml::Input::IInputScopeNameFactory>
    {
        int32_t __stdcall CreateInstance(int32_t nameValue, void** instance) noexcept final try
        {
            clear_abi(instance);
            typename D::abi_guard guard(this->shim());
            *instance = detach_from<Windows::UI::Xaml::Input::InputScopeName>(this->shim().CreateInstance(*reinterpret_cast<Windows::UI::Xaml::Input::InputScopeNameValue const*>(&nameValue)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs>
    {
        int32_t __stdcall get_Key(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKey>(this->shim().Key());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyStatus(struct struct_Windows_UI_Core_CorePhysicalKeyStatus* value) noexcept final try
        {
            zero_abi<Windows::UI::Core::CorePhysicalKeyStatus>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Core::CorePhysicalKeyStatus>(this->shim().KeyStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs2> : produce_base<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs2>
    {
        int32_t __stdcall get_OriginalKey(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKey>(this->shim().OriginalKey());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs3> : produce_base<D, Windows::UI::Xaml::Input::IKeyRoutedEventArgs3>
    {
        int32_t __stdcall get_DeviceId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceId());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyboardAccelerator> : produce_base<D, Windows::UI::Xaml::Input::IKeyboardAccelerator>
    {
        int32_t __stdcall get_Key(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKey>(this->shim().Key());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Key(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Key(*reinterpret_cast<Windows::System::VirtualKey const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Modifiers(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKeyModifiers>(this->shim().Modifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Modifiers(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Modifiers(*reinterpret_cast<Windows::System::VirtualKeyModifiers const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_IsEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().IsEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ScopeOwner(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().ScopeOwner());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ScopeOwner(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ScopeOwner(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Invoked(void* value, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Invoked(*reinterpret_cast<Windows::Foundation::TypedEventHandler<Windows::UI::Xaml::Input::KeyboardAccelerator, Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Invoked(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Invoked(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory> : produce_base<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory>
    {
        int32_t __stdcall CreateInstance(void* outer, void** inner, void** instance) noexcept final try
        {
            if (inner) *inner = nullptr;
            Windows::Foundation::IInspectable winrt_impl_inner;
            clear_abi(instance);
            typename D::abi_guard guard(this->shim());
            *instance = detach_from<Windows::UI::Xaml::Input::KeyboardAccelerator>(this->shim().CreateInstance(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&outer), winrt_impl_inner));
                if (inner) *inner = detach_abi(winrt_impl_inner);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs>
    {
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Element(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().Element());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2> : produce_base<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2>
    {
        int32_t __stdcall get_KeyboardAccelerator(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::KeyboardAccelerator>(this->shim().KeyboardAccelerator());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics> : produce_base<D, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics>
    {
        int32_t __stdcall get_KeyProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyProperty>(this->shim().KeyProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ModifiersProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyProperty>(this->shim().ModifiersProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsEnabledProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyProperty>(this->shim().IsEnabledProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ScopeOwnerProperty(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyProperty>(this->shim().ScopeOwnerProperty());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::ILosingFocusEventArgs> : produce_base<D, Windows::UI::Xaml::Input::ILosingFocusEventArgs>
    {
        int32_t __stdcall get_OldFocusedElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().OldFocusedElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NewFocusedElement(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::DependencyObject>(this->shim().NewFocusedElement());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NewFocusedElement(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NewFocusedElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_FocusState(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::FocusState>(this->shim().FocusState());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Direction(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusNavigationDirection>(this->shim().Direction());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InputDevice(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusInputDeviceKind>(this->shim().InputDevice());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cancel(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Cancel(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Cancel(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::ILosingFocusEventArgs2> : produce_base<D, Windows::UI::Xaml::Input::ILosingFocusEventArgs2>
    {
        int32_t __stdcall TryCancel(bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TryCancel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TrySetNewFocusedElement(void* element, bool* returnValue) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<bool>(this->shim().TrySetNewFocusedElement(*reinterpret_cast<Windows::UI::Xaml::DependencyObject const*>(&element)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs>
    {
        int32_t __stdcall get_Container(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::UIElement>(this->shim().Container());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInertial(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInertial());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cumulative(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Windows_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs>
    {
        int32_t __stdcall get_Container(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::UIElement>(this->shim().Container());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInertial(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInertial());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Delta(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Delta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cumulative(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Windows_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Complete() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Complete();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs>
    {
        int32_t __stdcall get_Container(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::UIElement>(this->shim().Container());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExpansionBehavior(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::InertiaExpansionBehavior>(this->shim().ExpansionBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExpansionBehavior(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExpansionBehavior(*reinterpret_cast<Windows::UI::Xaml::Input::InertiaExpansionBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RotationBehavior(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::InertiaRotationBehavior>(this->shim().RotationBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RotationBehavior(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RotationBehavior(*reinterpret_cast<Windows::UI::Xaml::Input::InertiaRotationBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TranslationBehavior(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::InertiaTranslationBehavior>(this->shim().TranslationBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TranslationBehavior(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TranslationBehavior(*reinterpret_cast<Windows::UI::Xaml::Input::InertiaTranslationBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Delta(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Delta());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cumulative(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Velocities(struct struct_Windows_UI_Input_ManipulationVelocities* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationVelocities>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationVelocities>(this->shim().Velocities());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationPivot> : produce_base<D, Windows::UI::Xaml::Input::IManipulationPivot>
    {
        int32_t __stdcall get_Center(Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Point>(this->shim().Center());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Center(Windows::Foundation::Point value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Center(*reinterpret_cast<Windows::Foundation::Point const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Radius(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Radius());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Radius(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Radius(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationPivotFactory> : produce_base<D, Windows::UI::Xaml::Input::IManipulationPivotFactory>
    {
        int32_t __stdcall CreateInstanceWithCenterAndRadius(Windows::Foundation::Point center, double radius, void** instance) noexcept final try
        {
            clear_abi(instance);
            typename D::abi_guard guard(this->shim());
            *instance = detach_from<Windows::UI::Xaml::Input::ManipulationPivot>(this->shim().CreateInstanceWithCenterAndRadius(*reinterpret_cast<Windows::Foundation::Point const*>(&center), radius));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs>
    {
        int32_t __stdcall get_Container(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::UIElement>(this->shim().Container());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Position(Windows::Foundation::Point* value) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Point>(this->shim().Position());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Cumulative(struct struct_Windows_UI_Input_ManipulationDelta* value) noexcept final try
        {
            zero_abi<Windows::UI::Input::ManipulationDelta>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Input::ManipulationDelta>(this->shim().Cumulative());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Complete() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Complete();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory> : produce_base<D, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory>
    {
        int32_t __stdcall CreateInstance(void* outer, void** inner, void** instance) noexcept final try
        {
            if (inner) *inner = nullptr;
            Windows::Foundation::IInspectable winrt_impl_inner;
            clear_abi(instance);
            typename D::abi_guard guard(this->shim());
            *instance = detach_from<Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs>(this->shim().CreateInstance(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&outer), winrt_impl_inner));
                if (inner) *inner = detach_abi(winrt_impl_inner);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs>
    {
        int32_t __stdcall get_Mode(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::ManipulationModes>(this->shim().Mode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Mode(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Mode(*reinterpret_cast<Windows::UI::Xaml::Input::ManipulationModes const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Container(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::UIElement>(this->shim().Container());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Container(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Container(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Pivot(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::ManipulationPivot>(this->shim().Pivot());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Pivot(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Pivot(*reinterpret_cast<Windows::UI::Xaml::Input::ManipulationPivot const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs> : produce_base<D, Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs>
    {
        int32_t __stdcall get_Direction(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusNavigationDirection>(this->shim().Direction());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_InputDevice(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::FocusInputDeviceKind>(this->shim().InputDevice());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IPointer> : produce_base<D, Windows::UI::Xaml::Input::IPointer>
    {
        int32_t __stdcall get_PointerId(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().PointerId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInContact(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInContact());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsInRange(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsInRange());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IPointerRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IPointerRoutedEventArgs>
    {
        int32_t __stdcall get_Pointer(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::UI::Xaml::Input::Pointer>(this->shim().Pointer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KeyModifiers(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKeyModifiers>(this->shim().KeyModifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCurrentPoint(void* relativeTo, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::UI::Input::PointerPoint>(this->shim().GetCurrentPoint(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetIntermediatePoints(void* relativeTo, void** returnValue) noexcept final try
        {
            clear_abi(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::Collections::IVector<Windows::UI::Input::PointerPoint>>(this->shim().GetIntermediatePoints(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IPointerRoutedEventArgs2> : produce_base<D, Windows::UI::Xaml::Input::IPointerRoutedEventArgs2>
    {
        int32_t __stdcall get_IsGenerated(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsGenerated());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs>
    {
        int32_t __stdcall get_Key(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKey>(this->shim().Key());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Modifiers(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::System::VirtualKeyModifiers>(this->shim().Modifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPosition(void* relativeTo, Windows::Foundation::Point* returnValue) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::Point>(this->shim().GetPosition(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, Windows::UI::Xaml::Input::ITappedRoutedEventArgs> : produce_base<D, Windows::UI::Xaml::Input::ITappedRoutedEventArgs>
    {
        int32_t __stdcall get_PointerDeviceType(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Devices::Input::PointerDeviceType>(this->shim().PointerDeviceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Handled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Handled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Handled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Handled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPosition(void* relativeTo, Windows::Foundation::Point* returnValue) noexcept final try
        {
            zero_abi<Windows::Foundation::Point>(returnValue);
            typename D::abi_guard guard(this->shim());
            *returnValue = detach_from<Windows::Foundation::Point>(this->shim().GetPosition(*reinterpret_cast<Windows::UI::Xaml::UIElement const*>(&relativeTo)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
namespace winrt::Windows::UI::Xaml::Input
{
    constexpr auto operator|(ManipulationModes const left, ManipulationModes const right) noexcept
    {
        return static_cast<ManipulationModes>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(ManipulationModes& left, ManipulationModes const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(ManipulationModes const left, ManipulationModes const right) noexcept
    {
        return static_cast<ManipulationModes>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(ManipulationModes& left, ManipulationModes const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(ManipulationModes const value) noexcept
    {
        return static_cast<ManipulationModes>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(ManipulationModes const left, ManipulationModes const right) noexcept
    {
        return static_cast<ManipulationModes>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(ManipulationModes& left, ManipulationModes const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline AccessKeyDisplayDismissedEventArgs::AccessKeyDisplayDismissedEventArgs() :
        AccessKeyDisplayDismissedEventArgs(impl::call_factory<AccessKeyDisplayDismissedEventArgs>([](auto&& f) { return f.template ActivateInstance<AccessKeyDisplayDismissedEventArgs>(); }))
    {
    }
    inline AccessKeyDisplayRequestedEventArgs::AccessKeyDisplayRequestedEventArgs() :
        AccessKeyDisplayRequestedEventArgs(impl::call_factory<AccessKeyDisplayRequestedEventArgs>([](auto&& f) { return f.template ActivateInstance<AccessKeyDisplayRequestedEventArgs>(); }))
    {
    }
    inline AccessKeyInvokedEventArgs::AccessKeyInvokedEventArgs() :
        AccessKeyInvokedEventArgs(impl::call_factory<AccessKeyInvokedEventArgs>([](auto&& f) { return f.template ActivateInstance<AccessKeyInvokedEventArgs>(); }))
    {
    }
    inline auto AccessKeyManager::IsDisplayModeEnabled()
    {
        return impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>([&](auto&& f) { return f.IsDisplayModeEnabled(); });
    }
    inline auto AccessKeyManager::IsDisplayModeEnabledChanged(Windows::Foundation::TypedEventHandler<Windows::Foundation::IInspectable, Windows::Foundation::IInspectable> const& value)
    {
        return impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>([&](auto&& f) { return f.IsDisplayModeEnabledChanged(value); });
    }
    inline AccessKeyManager::IsDisplayModeEnabledChanged_revoker AccessKeyManager::IsDisplayModeEnabledChanged(auto_revoke_t, Windows::Foundation::TypedEventHandler<Windows::Foundation::IInspectable, Windows::Foundation::IInspectable> const& value)
    {
        auto f = get_activation_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>();
        return { f, f.IsDisplayModeEnabledChanged(value) };
    }
    inline auto AccessKeyManager::IsDisplayModeEnabledChanged(winrt::event_token const& token)
    {
        impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>([&](auto&& f) { return f.IsDisplayModeEnabledChanged(token); });
    }
    inline auto AccessKeyManager::ExitDisplayMode()
    {
        impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics>([&](auto&& f) { return f.ExitDisplayMode(); });
    }
    inline auto AccessKeyManager::AreKeyTipsEnabled()
    {
        return impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics2>([&](auto&& f) { return f.AreKeyTipsEnabled(); });
    }
    inline auto AccessKeyManager::AreKeyTipsEnabled(bool value)
    {
        impl::call_factory<AccessKeyManager, Windows::UI::Xaml::Input::IAccessKeyManagerStatics2>([&](auto&& f) { return f.AreKeyTipsEnabled(value); });
    }
    inline ContextRequestedEventArgs::ContextRequestedEventArgs() :
        ContextRequestedEventArgs(impl::call_factory<ContextRequestedEventArgs>([](auto&& f) { return f.template ActivateInstance<ContextRequestedEventArgs>(); }))
    {
    }
    inline DoubleTappedRoutedEventArgs::DoubleTappedRoutedEventArgs() :
        DoubleTappedRoutedEventArgs(impl::call_factory<DoubleTappedRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<DoubleTappedRoutedEventArgs>(); }))
    {
    }
    inline FindNextElementOptions::FindNextElementOptions() :
        FindNextElementOptions(impl::call_factory<FindNextElementOptions>([](auto&& f) { return f.template ActivateInstance<FindNextElementOptions>(); }))
    {
    }
    inline auto FocusManager::GetFocusedElement()
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics>([&](auto&& f) { return f.GetFocusedElement(); });
    }
    inline auto FocusManager::TryMoveFocus(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics2>([&](auto&& f) { return f.TryMoveFocus(focusNavigationDirection); });
    }
    inline auto FocusManager::FindNextFocusableElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics3>([&](auto&& f) { return f.FindNextFocusableElement(focusNavigationDirection); });
    }
    inline auto FocusManager::FindNextFocusableElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::Foundation::Rect const& hintRect)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics3>([&](auto&& f) { return f.FindNextFocusableElement(focusNavigationDirection, hintRect); });
    }
    inline auto FocusManager::TryMoveFocus(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics4>([&](auto&& f) { return f.TryMoveFocus(focusNavigationDirection, focusNavigationOptions); });
    }
    inline auto FocusManager::FindNextElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics4>([&](auto&& f) { return f.FindNextElement(focusNavigationDirection); });
    }
    inline auto FocusManager::FindFirstFocusableElement(Windows::UI::Xaml::DependencyObject const& searchScope)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics4>([&](auto&& f) { return f.FindFirstFocusableElement(searchScope); });
    }
    inline auto FocusManager::FindLastFocusableElement(Windows::UI::Xaml::DependencyObject const& searchScope)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics4>([&](auto&& f) { return f.FindLastFocusableElement(searchScope); });
    }
    inline auto FocusManager::FindNextElement(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics4>([&](auto&& f) { return f.FindNextElement(focusNavigationDirection, focusNavigationOptions); });
    }
    inline auto FocusManager::TryFocusAsync(Windows::UI::Xaml::DependencyObject const& element, Windows::UI::Xaml::FocusState const& value)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics5>([&](auto&& f) { return f.TryFocusAsync(element, value); });
    }
    inline auto FocusManager::TryMoveFocusAsync(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics5>([&](auto&& f) { return f.TryMoveFocusAsync(focusNavigationDirection); });
    }
    inline auto FocusManager::TryMoveFocusAsync(Windows::UI::Xaml::Input::FocusNavigationDirection const& focusNavigationDirection, Windows::UI::Xaml::Input::FindNextElementOptions const& focusNavigationOptions)
    {
        return impl::call_factory<FocusManager, Windows::UI::Xaml::Input::IFocusManagerStatics5>([&](auto&& f) { return f.TryMoveFocusAsync(focusNavigationDirection, focusNavigationOptions); });
    }
    inline HoldingRoutedEventArgs::HoldingRoutedEventArgs() :
        HoldingRoutedEventArgs(impl::call_factory<HoldingRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<HoldingRoutedEventArgs>(); }))
    {
    }
    inline InputScope::InputScope() :
        InputScope(impl::call_factory<InputScope>([](auto&& f) { return f.template ActivateInstance<InputScope>(); }))
    {
    }
    inline InputScopeName::InputScopeName() :
        InputScopeName(impl::call_factory<InputScopeName>([](auto&& f) { return f.template ActivateInstance<InputScopeName>(); }))
    {
    }
    inline InputScopeName::InputScopeName(Windows::UI::Xaml::Input::InputScopeNameValue const& nameValue) :
        InputScopeName(impl::call_factory<InputScopeName, Windows::UI::Xaml::Input::IInputScopeNameFactory>([&](auto&& f) { return f.CreateInstance(nameValue); }))
    {
    }
    inline KeyboardAccelerator::KeyboardAccelerator()
    {
        Windows::Foundation::IInspectable outer, inner;
        *this = impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory>([&](auto&& f) { return f.CreateInstance(outer, inner); });
    }
    inline auto KeyboardAccelerator::KeyProperty()
    {
        return impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics>([&](auto&& f) { return f.KeyProperty(); });
    }
    inline auto KeyboardAccelerator::ModifiersProperty()
    {
        return impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics>([&](auto&& f) { return f.ModifiersProperty(); });
    }
    inline auto KeyboardAccelerator::IsEnabledProperty()
    {
        return impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics>([&](auto&& f) { return f.IsEnabledProperty(); });
    }
    inline auto KeyboardAccelerator::ScopeOwnerProperty()
    {
        return impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics>([&](auto&& f) { return f.ScopeOwnerProperty(); });
    }
    inline ManipulationCompletedRoutedEventArgs::ManipulationCompletedRoutedEventArgs() :
        ManipulationCompletedRoutedEventArgs(impl::call_factory<ManipulationCompletedRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<ManipulationCompletedRoutedEventArgs>(); }))
    {
    }
    inline ManipulationDeltaRoutedEventArgs::ManipulationDeltaRoutedEventArgs() :
        ManipulationDeltaRoutedEventArgs(impl::call_factory<ManipulationDeltaRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<ManipulationDeltaRoutedEventArgs>(); }))
    {
    }
    inline ManipulationInertiaStartingRoutedEventArgs::ManipulationInertiaStartingRoutedEventArgs() :
        ManipulationInertiaStartingRoutedEventArgs(impl::call_factory<ManipulationInertiaStartingRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<ManipulationInertiaStartingRoutedEventArgs>(); }))
    {
    }
    inline ManipulationPivot::ManipulationPivot() :
        ManipulationPivot(impl::call_factory<ManipulationPivot>([](auto&& f) { return f.template ActivateInstance<ManipulationPivot>(); }))
    {
    }
    inline ManipulationPivot::ManipulationPivot(Windows::Foundation::Point const& center, double radius) :
        ManipulationPivot(impl::call_factory<ManipulationPivot, Windows::UI::Xaml::Input::IManipulationPivotFactory>([&](auto&& f) { return f.CreateInstanceWithCenterAndRadius(center, radius); }))
    {
    }
    inline ManipulationStartedRoutedEventArgs::ManipulationStartedRoutedEventArgs()
    {
        Windows::Foundation::IInspectable outer, inner;
        *this = impl::call_factory<ManipulationStartedRoutedEventArgs, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory>([&](auto&& f) { return f.CreateInstance(outer, inner); });
    }
    inline ManipulationStartingRoutedEventArgs::ManipulationStartingRoutedEventArgs() :
        ManipulationStartingRoutedEventArgs(impl::call_factory<ManipulationStartingRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<ManipulationStartingRoutedEventArgs>(); }))
    {
    }
    inline RightTappedRoutedEventArgs::RightTappedRoutedEventArgs() :
        RightTappedRoutedEventArgs(impl::call_factory<RightTappedRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<RightTappedRoutedEventArgs>(); }))
    {
    }
    inline TappedRoutedEventArgs::TappedRoutedEventArgs() :
        TappedRoutedEventArgs(impl::call_factory<TappedRoutedEventArgs>([](auto&& f) { return f.template ActivateInstance<TappedRoutedEventArgs>(); }))
    {
    }
    template <typename L> DoubleTappedEventHandler::DoubleTappedEventHandler(L handler) :
        DoubleTappedEventHandler(impl::make_delegate<DoubleTappedEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> DoubleTappedEventHandler::DoubleTappedEventHandler(F* handler) :
        DoubleTappedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> DoubleTappedEventHandler::DoubleTappedEventHandler(O* object, M method) :
        DoubleTappedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> DoubleTappedEventHandler::DoubleTappedEventHandler(com_ptr<O>&& object, M method) :
        DoubleTappedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> DoubleTappedEventHandler::DoubleTappedEventHandler(weak_ref<O>&& object, M method) :
        DoubleTappedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto DoubleTappedEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<DoubleTappedEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> HoldingEventHandler::HoldingEventHandler(L handler) :
        HoldingEventHandler(impl::make_delegate<HoldingEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> HoldingEventHandler::HoldingEventHandler(F* handler) :
        HoldingEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> HoldingEventHandler::HoldingEventHandler(O* object, M method) :
        HoldingEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> HoldingEventHandler::HoldingEventHandler(com_ptr<O>&& object, M method) :
        HoldingEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> HoldingEventHandler::HoldingEventHandler(weak_ref<O>&& object, M method) :
        HoldingEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto HoldingEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::HoldingRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<HoldingEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> KeyEventHandler::KeyEventHandler(L handler) :
        KeyEventHandler(impl::make_delegate<KeyEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> KeyEventHandler::KeyEventHandler(F* handler) :
        KeyEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> KeyEventHandler::KeyEventHandler(O* object, M method) :
        KeyEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> KeyEventHandler::KeyEventHandler(com_ptr<O>&& object, M method) :
        KeyEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> KeyEventHandler::KeyEventHandler(weak_ref<O>&& object, M method) :
        KeyEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto KeyEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::KeyRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<KeyEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> ManipulationCompletedEventHandler::ManipulationCompletedEventHandler(L handler) :
        ManipulationCompletedEventHandler(impl::make_delegate<ManipulationCompletedEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> ManipulationCompletedEventHandler::ManipulationCompletedEventHandler(F* handler) :
        ManipulationCompletedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> ManipulationCompletedEventHandler::ManipulationCompletedEventHandler(O* object, M method) :
        ManipulationCompletedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationCompletedEventHandler::ManipulationCompletedEventHandler(com_ptr<O>&& object, M method) :
        ManipulationCompletedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationCompletedEventHandler::ManipulationCompletedEventHandler(weak_ref<O>&& object, M method) :
        ManipulationCompletedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto ManipulationCompletedEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<ManipulationCompletedEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> ManipulationDeltaEventHandler::ManipulationDeltaEventHandler(L handler) :
        ManipulationDeltaEventHandler(impl::make_delegate<ManipulationDeltaEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> ManipulationDeltaEventHandler::ManipulationDeltaEventHandler(F* handler) :
        ManipulationDeltaEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> ManipulationDeltaEventHandler::ManipulationDeltaEventHandler(O* object, M method) :
        ManipulationDeltaEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationDeltaEventHandler::ManipulationDeltaEventHandler(com_ptr<O>&& object, M method) :
        ManipulationDeltaEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationDeltaEventHandler::ManipulationDeltaEventHandler(weak_ref<O>&& object, M method) :
        ManipulationDeltaEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto ManipulationDeltaEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<ManipulationDeltaEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> ManipulationInertiaStartingEventHandler::ManipulationInertiaStartingEventHandler(L handler) :
        ManipulationInertiaStartingEventHandler(impl::make_delegate<ManipulationInertiaStartingEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> ManipulationInertiaStartingEventHandler::ManipulationInertiaStartingEventHandler(F* handler) :
        ManipulationInertiaStartingEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> ManipulationInertiaStartingEventHandler::ManipulationInertiaStartingEventHandler(O* object, M method) :
        ManipulationInertiaStartingEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationInertiaStartingEventHandler::ManipulationInertiaStartingEventHandler(com_ptr<O>&& object, M method) :
        ManipulationInertiaStartingEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationInertiaStartingEventHandler::ManipulationInertiaStartingEventHandler(weak_ref<O>&& object, M method) :
        ManipulationInertiaStartingEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto ManipulationInertiaStartingEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<ManipulationInertiaStartingEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> ManipulationStartedEventHandler::ManipulationStartedEventHandler(L handler) :
        ManipulationStartedEventHandler(impl::make_delegate<ManipulationStartedEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> ManipulationStartedEventHandler::ManipulationStartedEventHandler(F* handler) :
        ManipulationStartedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartedEventHandler::ManipulationStartedEventHandler(O* object, M method) :
        ManipulationStartedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartedEventHandler::ManipulationStartedEventHandler(com_ptr<O>&& object, M method) :
        ManipulationStartedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartedEventHandler::ManipulationStartedEventHandler(weak_ref<O>&& object, M method) :
        ManipulationStartedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto ManipulationStartedEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<ManipulationStartedEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> ManipulationStartingEventHandler::ManipulationStartingEventHandler(L handler) :
        ManipulationStartingEventHandler(impl::make_delegate<ManipulationStartingEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> ManipulationStartingEventHandler::ManipulationStartingEventHandler(F* handler) :
        ManipulationStartingEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartingEventHandler::ManipulationStartingEventHandler(O* object, M method) :
        ManipulationStartingEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartingEventHandler::ManipulationStartingEventHandler(com_ptr<O>&& object, M method) :
        ManipulationStartingEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> ManipulationStartingEventHandler::ManipulationStartingEventHandler(weak_ref<O>&& object, M method) :
        ManipulationStartingEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto ManipulationStartingEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<ManipulationStartingEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> PointerEventHandler::PointerEventHandler(L handler) :
        PointerEventHandler(impl::make_delegate<PointerEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> PointerEventHandler::PointerEventHandler(F* handler) :
        PointerEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> PointerEventHandler::PointerEventHandler(O* object, M method) :
        PointerEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> PointerEventHandler::PointerEventHandler(com_ptr<O>&& object, M method) :
        PointerEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> PointerEventHandler::PointerEventHandler(weak_ref<O>&& object, M method) :
        PointerEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto PointerEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::PointerRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<PointerEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> RightTappedEventHandler::RightTappedEventHandler(L handler) :
        RightTappedEventHandler(impl::make_delegate<RightTappedEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> RightTappedEventHandler::RightTappedEventHandler(F* handler) :
        RightTappedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> RightTappedEventHandler::RightTappedEventHandler(O* object, M method) :
        RightTappedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> RightTappedEventHandler::RightTappedEventHandler(com_ptr<O>&& object, M method) :
        RightTappedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> RightTappedEventHandler::RightTappedEventHandler(weak_ref<O>&& object, M method) :
        RightTappedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto RightTappedEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::RightTappedRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<RightTappedEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename L> TappedEventHandler::TappedEventHandler(L handler) :
        TappedEventHandler(impl::make_delegate<TappedEventHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> TappedEventHandler::TappedEventHandler(F* handler) :
        TappedEventHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> TappedEventHandler::TappedEventHandler(O* object, M method) :
        TappedEventHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> TappedEventHandler::TappedEventHandler(com_ptr<O>&& object, M method) :
        TappedEventHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> TappedEventHandler::TappedEventHandler(weak_ref<O>&& object, M method) :
        TappedEventHandler([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto TappedEventHandler::operator()(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::Input::TappedRoutedEventArgs const& e) const
    {
        check_hresult((*(impl::abi_t<TappedEventHandler>**)this)->Invoke(*(void**)(&sender), *(void**)(&e)));
    }
    template <typename D, typename... Interfaces>
    struct KeyboardAcceleratorT :
        implements<D, Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, Windows::UI::Xaml::Input::IKeyboardAccelerator, Windows::UI::Xaml::IDependencyObject, Windows::UI::Xaml::IDependencyObject2>,
        impl::base<D, KeyboardAccelerator, Windows::UI::Xaml::DependencyObject>
    {
        using composable = KeyboardAccelerator;
    protected:
        KeyboardAcceleratorT()
        {
            impl::call_factory<KeyboardAccelerator, Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory>([&](auto&& f) { f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct ManipulationStartedRoutedEventArgsT :
        implements<D, Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs, Windows::UI::Xaml::IRoutedEventArgs>,
        impl::base<D, ManipulationStartedRoutedEventArgs, Windows::UI::Xaml::RoutedEventArgs>
    {
        using composable = ManipulationStartedRoutedEventArgs;
    protected:
        ManipulationStartedRoutedEventArgsT()
        {
            impl::call_factory<ManipulationStartedRoutedEventArgs, Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory>([&](auto&& f) { f.CreateInstance(*this, this->m_inner); });
        }
    };
}
namespace std
{
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyDisplayDismissedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyDisplayRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IAccessKeyManagerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ICharacterReceivedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ICommand> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IContextRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IDoubleTappedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFindNextElementOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManagerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManagerStatics2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManagerStatics3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManagerStatics4> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusManagerStatics5> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IFocusMovementResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IGettingFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IGettingFocusEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IHoldingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInertiaExpansionBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInertiaRotationBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInertiaTranslationBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInputScope> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInputScopeName> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IInputScopeNameFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyRoutedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyRoutedEventArgs3> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyboardAccelerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyboardAcceleratorFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyboardAcceleratorInvokedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IKeyboardAcceleratorStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ILosingFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ILosingFocusEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationCompletedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationDeltaRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationInertiaStartingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationPivot> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationPivotFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationStartedRoutedEventArgsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IManipulationStartingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::INoFocusCandidateFoundEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IPointer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IPointerRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IPointerRoutedEventArgs2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IProcessKeyboardAcceleratorEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::IRightTappedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ITappedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::AccessKeyManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::DoubleTappedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::FindNextElementOptions> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::FocusManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::FocusMovementResult> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::HoldingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::InertiaExpansionBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::InertiaRotationBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::InertiaTranslationBehavior> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::InputScope> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::InputScopeName> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::KeyRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::KeyboardAccelerator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorInvokedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationCompletedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationDeltaRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationPivot> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationStartedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ManipulationStartingRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::Pointer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::PointerRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::RightTappedRoutedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Windows::UI::Xaml::Input::TappedRoutedEventArgs> : winrt::impl::hash_base {};
}
#endif
